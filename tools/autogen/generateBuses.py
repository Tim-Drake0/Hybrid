import yaml
import os

# ---------------- CONFIG ----------------
yaml_file = "C:/Git/Hybrid/tools/buses/busDef.yaml"
arduino_sketch_dir = "C:/Git/Hybrid/tools/buses/main"
output_dir = os.path.join(arduino_sketch_dir, "src")
os.makedirs(output_dir, exist_ok=True)
# ---------------------------------------

type_map = {
    int: "int",
    float: "double",
    str: "char",
    bool: "bool"
}

# Load YAML
with open(yaml_file, "r") as f:
    buses = yaml.safe_load(f)
    
for bus_name, bus_info in buses.items():
    print(bus_name)
    
    valuesLines = ""
    ifLines = ""
    serializeInputLine = ""
    floatUn = ""
    floatVar=""
    buffer = ""
    
    i=0
    buff_index = 0
    for field_name, field_props in bus_info['data'].items(): # look at each variable
        i=i+1
        #valuesLines += f"    {field_props.values()},\n"
        thisLine = "{"
        for index, value in enumerate(field_props.values()): # get properties of each variable
            if index == len(field_props.values())-1:
                thisLine += f" {value}}}"
            elif index == 1 or index == 2:
                thisLine += f' "{value}",'
            else:
                thisLine += f" {value},"
                
        if field_props['type'] == "float":
            floatUn += f"union {{float f;uint32_t u;}} {field_name}_u;\n    "
            floatVar += f"{field_name}_u.f = {field_name};\n    "
            tempName = field_name + "_u.u"
        else:
            tempName = field_name
            
        # do bit math    
        if i == len(bus_info['data'].items()): # double indent if not the last one
            valuesLines += f"    {thisLine}"
            serializeInputLine += f"{field_props['type']} {field_name}"
            if field_props['type'] == "float" or field_props['type'] == "uint32_t": # if float or 32bit int then split up into 4 bytes
                buffer += f"buffer[{buff_index}] = ({tempName} >> 24) & 0xFF; // Most significant byte (MSB)\n    buffer[{buff_index+1}] = ({tempName} >> 16) & 0xFF;\n    buffer[{buff_index+2}] = ({tempName} >> 8)  & 0xFF;\n    buffer[{buff_index+3}] = {tempName} & 0xFF;         // Least significant byte (LSB)"
                buff_index = buff_index+4
            elif field_props['type'] == "uint16_t": # if 16bit int then split up into 2 bytes
                buffer += f"buffer[{buff_index}] = ({tempName} >> 8) & 0xFF;  // High byte (bits 9-8)\n    buffer[{buff_index+1}] = {tempName} & 0xFF;         // Low byte (bits 7-0)"
                buff_index = buff_index+2
                                    
        else:
            valuesLines += f"    {thisLine},\n"
            serializeInputLine += f"{field_props['type']} {field_name}, "
            if field_props['type'] == "float" or field_props['type'] == "uint32_t": # if float or 32bit int then split up into 4 bytes
                buffer += f"buffer[{buff_index}] = ({tempName} >> 24) & 0xFF; // Most significant byte (MSB)\n    buffer[{buff_index+1}] = ({tempName} >> 16) & 0xFF;\n    buffer[{buff_index+2}] = ({tempName} >> 8)  & 0xFF;\n    buffer[{buff_index+3}] = {tempName} & 0xFF;         // Least significant byte (LSB)\n\n    "
                buff_index = buff_index+4
            elif field_props['type'] == "uint16_t": # if 16bit int then split up into 2 bytes
                buffer += f"buffer[{buff_index}] = ({tempName} >> 8) & 0xFF;  // High byte (bits 9-8)\n    buffer[{buff_index+1}] = {tempName} & 0xFF;         // Low byte (bits 7-0)\n\n    "
                buff_index = buff_index+2    
                
        ifLines += f'   if (strcmp(fieldName, "{field_name}") == 0) return &{field_name};\n'

    # -------- busPwr.h ---------------------------------------------------------------------------------------------------------
    header_path = os.path.join(output_dir, bus_name + ".h")

    h_template = """
//This was autogenerated by generateBuses.py

#ifndef {ifndef}
#define {ifndef}
#include <Arduino.h>

struct {fieldConfig} {{
    int initVal;
    const char* unit;
    const char* type;
    int startByte;
    int bytes;
    int bits;
    double c0;
    double c1;
    uint32_t pin;
}};

struct {busConfig} {{
    int id;
    int size;
    int frequency;
    const char* endian;
{fieldConfigLines} 
    const {fieldConfig}* getField(const char* fieldName) const;
    int bufferSize() const;
    std::array<uint8_t, {size}> serialize({serializeInputLine}) const;
}};

extern const {busConfig} {busName};

#endif

"""

    fieldConfigLines = ""
    for field_name, field_props in bus_info['data'].items():
        fieldConfigLines += f"    {bus_name + "FieldConfig"} {field_name};\n"
        
    output = h_template.format(
        busName=bus_name,
        ifndef=bus_name.upper() + "_H",
        fieldConfig=bus_name + "FieldConfig",
        busConfig=bus_name + "Config",
        fieldConfigLines=fieldConfigLines,
        size=bus_info['size'],
        serializeInputLine=serializeInputLine,
    )
    
    with open(header_path, "w") as f:
        f.write(output)


    # -------- busPwr.cpp ---------------------------------------------------------------------------------------------------------
    cpp_path = os.path.join(output_dir, bus_name + ".cpp")
    
    cpp_template = """
//This was autogenerated by generateBuses.py

#include {busdotH}
#include <string.h>
#include <Arduino.h>

const {busConfig} {busName} = {{
    {id},
    {size},
    {freq},
    {endian},
{vals}
}};

const {fieldConfig}* {busConfig}::getField(const char* fieldName) const {{
{ifLines}
    return nullptr;
    
}}

std::array<uint8_t, {size}> {busConfig}::serialize({serializeInputLine}) const {{
    std::array<uint8_t, {size}> buffer{{}};
    buffer.fill(0);
    
    {floatUn}
    {floatVar}
    {buffer}
    
    return buffer;
}}


"""

 
  
        
        
        
    output = cpp_template.format(
        busName=bus_name,
        busdotH=f'"{bus_name}.h"',
        fieldConfig=bus_name + "FieldConfig",
        busConfig=bus_name + "Config",
        id=bus_info['id'],
        size=bus_info['size'],
        freq=bus_info['freq'],
        endian=f'"{bus_info['endian']}"',
        vals=valuesLines,
        ifLines=ifLines,
        serializeInputLine=serializeInputLine,
        floatUn=floatUn,
        floatVar=floatVar,
        buffer=buffer,
    )
    with open(cpp_path, "w") as f:
        f.write(output)

    print(f"Generated files in Arduino sketch folder:\n- {header_path}\n- {cpp_path}")
