import yaml
import os

# ---------------- CONFIG ----------------
yaml_file = "C:/Git/Hybrid/tools/buses/streamDef.yaml"
bus_yaml_file = "C:/Git/Hybrid/tools/buses/busDef.yaml"
tools_dir = "C:/Git/Hybrid/tools"
output_dir = os.path.join(tools_dir, "serialGUI")
os.makedirs(output_dir, exist_ok=True)
# ---------------------------------------

# Load YAML
with open(yaml_file, "r") as f:
    streams = yaml.safe_load(f)
    
with open(bus_yaml_file, "r") as f:
    buses = yaml.safe_load(f)
    
    
streamSize = 9 #header, id, and timestamp
for stream_name, stream_info in streams.items():
    
    classBusLines = ""
    
    for index, busName in enumerate(stream_info['buses']): # look at each variable
        
        for bus_name, bus_info in buses.items():
            if bus_name == busName:
                busID = bus_info["id"]
                busSize = bus_info["size"]
                streamSize = streamSize + busSize
                
              
        classBusLines += f'class {busName[0].upper() + busName[1:]}:\n' # capitalize the first b in bus for the class
        classBusLines += f'    timestamp:   int = 0\n'
        classBusLines += f'    id:          int = {busID}\n'
        classBusLines += f'    size:        int = {busSize}\n'
        classBusLines += f'    packetsSent: int = 0\n'
        
        # Initialize variables
        for bus_name, bus_info in buses.items():
            if bus_name == busName:
                for field_name, field_props in bus_info['data'].items(): # look at each variable
                    fieldType = field_props["type"]
                    if fieldType == "uint16_t":
                        fieldType = "float"
                        
                    classBusLines += f'    {field_name}:   {fieldType} = {field_props["initVal"]}\n'
        
        if busName == "busPwr":
            classBusLines += f'    voltsLSB: float = 0.00322265625\n'
        
        # Make read buffer functions
        classBusLines += f'\n'
        classBusLines += f'    def readBuffer(self, packet, idx):\n'
        classBusLines += f'        self.id           = bytes2Num(packet, idx, 2);    idx += 2\n'
        classBusLines += f'        self.timestamp    = bytes2Num(packet, idx, 4);    idx += 4\n'
        classBusLines += f'        self.packetsSent  = bytes2Num(packet, idx, 2);    idx += 2\n'
        
        
        for bus_name, bus_info in buses.items():
            if bus_name == busName:
                
                for field_name, field_props in bus_info['data'].items(): # look at each variable
                    if busName == "busPwr":
                        classBusLines += f'        self.{field_name}    = bytes2Num(packet, idx, {field_props["bytes"]}) * self.voltsLSB; idx += {field_props["bytes"]}\n'
                    else:   
                        classBusLines += f'        self.{field_name}    = bytes2Float(packet, idx); idx += {field_props["bytes"]}\n'
        

        classBusLines += f'\n'
        
    classBusLines += f'\n'  
    classBusLines += f'class StreamTelem:\n' 
    classBusLines += f'    header:      int = {stream_info["header"]}\n'
    classBusLines += f'    timestamp:   int = 0\n'
    classBusLines += f'    id:          int = {stream_info["id"]}\n'
    classBusLines += f'    size:        int = {stream_info["size"]}\n'
    classBusLines += f'    packetsSent: int = 0\n'    
    classBusLines += f'    packet:      int = [0] * size\n'    
    classBusLines += f'    sensorsBIT:  int = 0\n'    
        
    
    
deserialize_path = os.path.join(output_dir, "deserializeBuses.py")

d_template = """
'''
This was autogenerated by generateDeserializeBuses.py

'''

import serial_reader as sr
import struct

accelLSB: float = 0.00122; # 2G = 0.00061, 4G = 0.00122, 8G = 0.00244, 16G = 0.00732
magLSB: float = 0.00014; # 4GAUSS = 0.00014, 8GAUSS = 0.00029, 12GAUSS = 0.00043, 16GAUSS = 0.00058
gyroLSB: float = 0.07000; # 245DPS = 0.00875, 500DPS = 0.01750, 2000DPS = 0.07000

# ---------------- HELPERS ----------------
def bytes2Num(packet, startByte, bytes):
    if bytes == 2:
        return (packet[startByte] << 8) | packet[startByte+1]
    if bytes == 4:
        return (packet[startByte] << 24) | (packet[startByte+1] << 16) | (packet[startByte+2] << 8) | packet[startByte+3]
    
def bytes2Volts(packet, startByte):
    raw_volts = (packet[startByte] << 8) | packet[startByte+1]
    return (raw_volts / 1024) * 3.3

def bytes2Float(packet, startByte):
    raw_bytes = bytes(packet[startByte:startByte+4])
    return struct.unpack('>f', raw_bytes)[0]
    
{classBus}
    def find_and_read_packet(self):
        # maybe add timeout to this>
        
        while True:
            thisPacket = sr.ser.read(self.size)
            
            if len(thisPacket) != self.size:
                continue
            
            if (thisPacket[0] != (self.header >> 8) & 0xFF or thisPacket[1] != self.header & 0xFF 
            or thisPacket[2] != (self.id >> 8) & 0xFF or thisPacket[3] != self.id & 0xFF):
                continue
            
            self.packet = thisPacket
            return
            
"""

    
output = d_template.format(
    classBus=classBusLines,
)

with open(deserialize_path, "w") as f:
    f.write(output)
    
    
    
    
    
    
    
    
    
    
    
    